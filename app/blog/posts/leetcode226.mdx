---
title: 'Leetcode 226. Invert Binary Tree'
publishedAt: '2024-12-04'
summary: 'Tree'
number: '226'
---

## 226. Invert Binary Tree

Given the `root` of a binary tree, invert the tree, and return its root.

Example 1
`````
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
`````

Example 2
`````
Input: root = [2,1,3]
Output: [2,3,1]
`````

Example 3
`````
Input: root = []
Output: []
`````

Constraints:

- The number of nodes in the tree is in the range `[0, 100]`.
- `-100 <= Node.val <= 100`

## Solution
Approach 1: Preorder Traversal, Recursion
````JAVA
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// Time complexity: O(n)
class Solution {
    public TreeNode invertTree(TreeNode root) {
        
        if (root == null) return root;
        
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        invertTree(root.left);
        invertTree(root.right);
        
        return root;
    }
}
````

## Solution
Approach 1.2: Preorder Traversal, Recursion
````JAVA
// Time complexity: O(n)
class Solution {
    public TreeNode invertTree(TreeNode root) {
        
        if (root == null) { return root; }
        
        swap(root);
        invertTree(root.left);
        invertTree(root.right);

        return root;
    }
    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
````

Approach 1.3:  Preorder Traversal, Iteration


Approach 2: Postorder Traversal, Recursion
````JAVA
class Solution {
    public TreeNode invertTree(TreeNode root) {
        
        if (root == null) { return root; }
        
        invertTree(root.left);
        invertTree(root.right);
        swap(root);

        return root;
    }
    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
````

Approach 2.2: Postorder Traversal, Iteration

Approach 3: Level Order Traversal, Recursion
Approach 3.2: Level Order Traversal, Iteration

Approach 4: Inorder Traversal, Recursion, (Not Recommend approach since it only swap the root.left)
Approach 4.2: Level Order Traversal, Iteration